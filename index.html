<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>TCG Master Ver.37</title>
<style>
  :root { --primary: #007aff; --danger: #ff3b30; --success: #34c759; --warning: #ff9500; }
  body { margin: 0; padding: 16px; font-family: -apple-system, sans-serif; background: #f0f0f0; user-select: none; }
  
  /* 情報表示 */
  .info-bar { background: #333; color: white; padding: 10px; border-radius: 8px; margin-bottom: 12px; font-size: 13px; line-height: 1.6; }
  .info-bar b { color: #5ac8fa; transition: all 0.3s; }
  .status { margin-bottom: 8px; font-size: 14px; text-align: center; height: 45px; }
  .active-turn { color: var(--primary); font-weight: bold; border: 2px solid var(--primary); padding: 6px; border-radius: 8px; background: #e6f0ff; display: block; }

  /* 画面切り替え */
  #editor-view, #game-view { display: none; }

  /* デッキ編集 */
  .view-card { background: #fff; padding: 20px; border-radius: 12px; border: 3px solid var(--primary); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
  .master-list { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; padding: 10px; background: #eee; border-radius: 8px; justify-content: center; max-height: 300px; overflow-y: auto; }
  .deck-count { font-size: 24px; font-weight: bold; color: var(--danger); text-align: center; margin-bottom: 10px; }

  /* フィールド */
  .field-container { display: flex; flex-direction: column; gap: 10px; background: #ddd; padding: 10px; border-radius: 8px; margin: 15px 0; min-height: 260px; border: 2px dashed #999; }
  .field-side { display: flex; gap: 8px; justify-content: center; min-height: 115px; align-items: center; }
  
  /* カード */
  .card { width: 85px; height: 115px; background: white; border-radius: 6px; padding: 6px; text-align: center; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; flex-direction: column; border: 2px solid transparent; flex-shrink: 0; box-sizing: border-box; transition: 0.2s; }
  .card-name { font-weight: bold; height: 2.4em; overflow: hidden; line-height: 1.2; }
  .tag { font-size: 8px; padding: 1px 4px; border-radius: 3px; background: #eee; margin: 2px; display: inline-block; border: 0.5px solid #ccc; }
  .atk { color: var(--danger); font-weight: bold; font-size: 14px; margin-top: auto; }
  .atk::before { content: "ATK "; font-size: 9px; }

  /* 状態表示 */
  .exhausted { opacity: 0.5; filter: grayscale(1); }
  .selected { border-color: var(--warning); box-shadow: 0 0 10px var(--warning); transform: translateY(-5px); }
  .targetable { border-color: var(--danger); animation: blink 0.8s infinite; }
  .sacrifice-target { border-color: var(--primary); animation: blink 0.8s infinite; cursor: pointer; }
  
  /* 直接攻撃ターゲット点滅 */
  .direct-target { background: var(--danger) !important; color: white !important; animation: blink 0.5s infinite; border-radius: 4px; padding: 0 4px; }

  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

  button { width: 100%; height: 50px; font-size: 16px; border: none; border-radius: 8px; background: var(--primary); color: white; margin-bottom: 10px; font-weight: bold; cursor: pointer; }
  button:disabled { background: #aaa; cursor: not-allowed; }
  #hand { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 10px; }

  .end-screen { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); color:white; display:none; flex-direction:column; align-items:center; justify-content:center; z-index:100; }
</style>
</head>
<body onclick="cancelActions(event)">

  <div id="editor-view" class="view-card">
    <h2>デッキ作成：<span id="editorPlayerName"></span></h2>
    <div class="deck-count">残り: <span id="deckRemain">18</span>枚</div>
    <div id="masterList" class="master-list"></div>
    <button onclick="randomDeck()" style="background:var(--success)">おまかせ作成</button>
    <button onclick="currentDeck=[]; updateEditorUI()" style="background:#8e8e93">クリア</button>
    <button id="saveDeckBtn" onclick="saveDeckToFirebase()" disabled>サーバーへ保存</button>
    <div id="savedMsg" style="text-align:center; color:var(--success); font-weight:bold; margin-top:5px;"></div>
  </div>

  <div id="game-view">
    <div class="info-bar">
      <div>ROOM ID: <b id="displayRoomId">-</b></div>
      <div>あなた: <b id="displayMyName">-</b> (ダメージ: <span id="myDamage">0</span>/3)</div>
      <div id="oppArea">相手: <b id="displayOppName">-</b> (ダメージ: <span id="oppDamage">0</span>/3)</div>
    </div>

    <div id="setup-area">
      <button onclick="startGameSync()" style="background:var(--success)">対戦開始（全員のデッキを同期）</button>
    </div>

    <div class="status"><span id="currentTurnOwner">待機中</span></div>
    
    <div class="field-container">
      <div id="opponentField" class="field-side"></div>
      <hr style="width:100%; border:0; border-top:1px solid #bbb;">
      <div id="myField" class="field-side"></div>
    </div>

    <button id="turnEndBtn" onclick="endTurn()" style="background:var(--warning)" disabled>ターン終了</button>
    <div id="hand"></div>
    <button onclick="resetGame()" style="background:var(--danger); margin-top:20px; font-size:12px; height:30px;">ゲームを完全リセット</button>
  </div>

  <div id="end-screen" class="end-screen">
    <h1 id="end-message"></h1>
    <button onclick="resetGame()" style="width:200px; background:var(--danger)">リセットして戻る</button>
  </div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCzUHmyYcQlYkJmeXX5Cxp_fNFkonOSE3I",
    authDomain: "tcgtk-51f73.firebaseapp.com",
    databaseURL: "https://tcgtk-51f73-default-rtdb.firebaseio.com",
    projectId: "tcgtk-51f73",
    storageBucket: "tcgtk-51f73.firebasestorage.app",
    messagingSenderId: "379251900306",
    appId: "1:379251900306:web:beeb1989bedcca4dcbcb4b"
  };
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();

  const params = new URLSearchParams(window.location.search);
  const roomId = params.get("room");
  const myPlayerId = params.get("player") || "player1";
  const opponentPlayerId = myPlayerId === "player1" ? "player2" : "player1";

  const cardPool = [
    {n:"火の精霊", a:400, t:["火"]}, {n:"水の精霊", a:400, t:["水"]},
    {n:"光の騎士", a:700, t:["光"]}, {n:"雷神", a:800, t:["光"]},
    {n:"戦乙女", a:750, t:["光"]}, {n:"大盾兵", a:300, t:["地"]},
    {n:"スライム", a:100, t:["水"]}, {n:"ドラゴン", a:900, t:["火", "特殊"]},
    {n:"ゴブリン", a:200, t:["地"]}, {n:"ナイト", a:500, t:["闇"]},
    {n:"不死鳥", a:1000, t:["火", "特殊"]}, {n:"死神", a:700, t:["闇", "即死"]}
  ];

  if (roomId) {
    document.getElementById("game-view").style.display = "block";
    initGameLogic();
  } else {
    document.getElementById("editor-view").style.display = "block";
    initEditorLogic();
  }

  // --- デッキ編集 ---
  let currentDeck = [];
  function initEditorLogic() {
    document.getElementById("editorPlayerName").textContent = myPlayerId;
    const list = document.getElementById("masterList");
    cardPool.forEach(c => {
      const el = createCardEl(c);
      el.onclick = () => { if(currentDeck.length < 18) { currentDeck.push({...c}); updateEditorUI(); } };
      list.appendChild(el);
    });
    database.ref(`decks/${myPlayerId}`).get().then(s => { if(s.exists()){ currentDeck = s.val(); updateEditorUI(); }});
  }

  function updateEditorUI() {
    const remain = 18 - currentDeck.length;
    document.getElementById("deckRemain").textContent = remain;
    document.getElementById("saveDeckBtn").disabled = (remain !== 0);
  }

  function randomDeck() {
    currentDeck = [];
    for(let i=0; i<18; i++) currentDeck.push({...cardPool[Math.floor(Math.random()*cardPool.length)]});
    updateEditorUI();
  }

  function saveDeckToFirebase() {
    database.ref(`decks/${myPlayerId}`).set(currentDeck).then(() => {
      document.getElementById("savedMsg").textContent = "保存完了！対戦URLを開いてください。";
    });
  }

  // --- 対戦ロジック ---
  let myHand=[], myField=[], oppField=[], isMyTurn=false, selectedIdx=null, sacrificeHandIdx=null, turnCount=0;

  function initGameLogic() {
    document.getElementById("displayRoomId").textContent = roomId;
    document.getElementById("displayMyName").textContent = myPlayerId;
    document.getElementById("displayOppName").textContent = opponentPlayerId;

    database.ref(`games/${roomId}`).on("value", snap => {
      const data = snap.val();
      if (!data) { resetLocalUI(); return; }
      turnCount = data.turnCount || 0;
      const me = data[myPlayerId] || {};
      const opp = data[opponentPlayerId] || {};
      if (me.damage >= 3) showEnd("DEFEAT...");
      else if (opp.damage >= 3) showEnd("YOU WIN!");
      else document.getElementById("end-screen").style.display = "none";
      document.getElementById("myDamage").textContent = me.damage || 0;
      document.getElementById("oppDamage").textContent = opp.damage || 0;
      if (data.currentTurn) {
        document.getElementById("setup-area").style.display = "none";
        isMyTurn = (data.currentTurn === myPlayerId);
        if (isMyTurn && window.lastTurnKey !== (data.currentTurn + turnCount)) {
          window.lastTurnKey = (data.currentTurn + turnCount);
          setTimeout(autoDraw, 600);
        }
      }
      myHand = me.handList || [];
      myField = me.field || [];
      oppField = opp.field || [];
      updateUI();
    });
  }

  async function startGameSync() {
    const [mySnap, oppSnap] = await Promise.all([
      database.ref(`decks/${myPlayerId}`).get(),
      database.ref(`decks/${opponentPlayerId}`).get()
    ]);
    if (!mySnap.exists() || !oppSnap.exists()) return alert("全員のデッキ保存が必要です");
    const myD = mySnap.val().sort(() => Math.random() - 0.5);
    const oppD = oppSnap.val().sort(() => Math.random() - 0.5);
    database.ref(`games/${roomId}`).set({
      currentTurn: "player1", turnCount: 1,
      [myPlayerId]: { deck: myD.slice(3), handList: myD.slice(0, 3), field: [], damage: 0 },
      [opponentPlayerId]: { deck: oppD.slice(3), handList: oppD.slice(0, 3), field: [], damage: 0 }
    });
  }

  function autoDraw() {
    database.ref(`games/${roomId}/${myPlayerId}`).get().then(s => {
      const d = s.val();
      if (!d || !d.deck || d.deck.length === 0) return;
      const newDeck = [...d.deck];
      const card = newDeck.shift();
      database.ref(`games/${roomId}/${myPlayerId}`).update({ deck: newDeck, handList: [...(d.handList||[]), card] });
    });
  }

  function playCard(i, e) {
    e.stopPropagation();
    if (!isMyTurn) return;
    const c = myHand[i];
    if (c.n === "不死鳥" || c.n === "ドラゴン") {
      if (myField.length === 0) return alert("生贄が必要です");
      sacrificeHandIdx = i; updateUI(); return;
    }
    if (myField.length >= 3) return alert("場は3枚まで");
    const h = [...myHand]; h.splice(i, 1);
    database.ref(`games/${roomId}/${myPlayerId}`).update({ handList: h, field: [...myField, {...c, hasAttacked:false}] });
  }

  function completeSacrifice(fi, e) {
    e.stopPropagation();
    const c = myHand[sacrificeHandIdx];
    let h = [...myHand]; h.splice(sacrificeHandIdx, 1);
    let f = [...myField]; f.splice(fi, 1); 
    f.push({...c, hasAttacked: false});
    sacrificeHandIdx = null;
    database.ref(`games/${roomId}/${myPlayerId}`).update({ handList: h, field: f });
  }

  function selectMyCard(i, e) {
    e.stopPropagation();
    if (turnCount === 1) return alert("先行1ターン目は攻撃不可");
    if (!isMyTurn || myField[i].hasAttacked || sacrificeHandIdx !== null) return;
    selectedIdx = (selectedIdx === i) ? null : i; updateUI();
  }

  function attackOpp(oi, e) {
    e.stopPropagation();
    const mc = myField[selectedIdx];
    const oc = oppField[oi];
    let mf = [...myField], of = [...oppField];
    mf[selectedIdx].hasAttacked = true;
    if (mc.n === "死神" || mc.a > oc.a) of.splice(oi, 1);
    else if (mc.a < oc.a) mf.splice(selectedIdx, 1);
    else { mf.splice(selectedIdx, 1); of.splice(oi, 1); }
    selectedIdx = null;
    database.ref(`games/${roomId}`).update({ [`/${myPlayerId}/field`]: mf, [`/${opponentPlayerId}/field`]: of });
  }

  function directAtk(e) {
    if (e) e.stopPropagation();
    if (selectedIdx === null) return;
    database.ref(`games/${roomId}/${opponentPlayerId}/damage`).transaction(d => (d || 0) + 1);
    let f = [...myField]; f[selectedIdx].hasAttacked = true;
    database.ref(`games/${roomId}/${myPlayerId}/field`).set(f);
    // 攻撃後に選択をクリア。updateUIでハイライトも消える
    selectedIdx = null;
  }

  function endTurn() {
    selectedIdx = null; sacrificeHandIdx = null;
    database.ref(`games/${roomId}`).transaction(d => {
      if (d) {
        if (d.player1 && d.player1.field) d.player1.field.forEach(c => c.hasAttacked = false);
        if (d.player2 && d.player2.field) d.player2.field.forEach(c => c.hasAttacked = false);
        d.currentTurn = opponentPlayerId;
        d.turnCount = (d.turnCount || 0) + 1;
      }
      return d;
    });
  }

  function updateUI() {
    const sEl = document.querySelector(".status span");
    sEl.textContent = isMyTurn ? (turnCount===1 ? "先行：攻撃不可" : (sacrificeHandIdx!==null ? "生贄選択中" : "あなたの番")) : "相手の番";
    sEl.parentElement.className = isMyTurn ? "status active-turn" : "status";
    document.getElementById("turnEndBtn").disabled = !isMyTurn;

    // 直接攻撃ハイライト制御
    const oa = document.getElementById("oppArea");
    const oppNameB = oa.querySelector("b");
    if (isMyTurn && selectedIdx !== null && oppField.length === 0) {
      oppNameB.classList.add("direct-target");
      oa.style.cursor = "pointer";
      oa.onclick = directAtk;
    } else {
      oppNameB.classList.remove("direct-target");
      oa.style.cursor = "default";
      oa.onclick = null;
    }

    const hD = document.getElementById("hand"); hD.innerHTML = "";
    myHand.forEach((c, i) => {
      const el = createCardEl(c); if(sacrificeHandIdx===i) el.classList.add("selected");
      el.onclick = (e) => playCard(i, e); hD.appendChild(el);
    });

    const mF = document.getElementById("myField"); mF.innerHTML = "";
    myField.forEach((c, i) => {
      const el = createCardEl(c);
      if (sacrificeHandIdx !== null) { el.classList.add("sacrifice-target"); el.onclick = (e) => completeSacrifice(i, e); }
      else {
        if (c.hasAttacked) el.classList.add("exhausted");
        if (isMyTurn && !c.hasAttacked) { el.onclick = (e) => selectMyCard(i, e); if (selectedIdx === i) el.classList.add("selected"); }
      }
      mF.appendChild(el);
    });

    const oF = document.getElementById("opponentField"); oF.innerHTML = "";
    oppField.forEach((c, i) => {
      const el = createCardEl(c); if(selectedIdx !== null) { el.classList.add("targetable"); el.onclick = (e) => attackOpp(i, e); }
      oF.appendChild(el);
    });
  }

  function createCardEl(c) {
    const d = document.createElement("div"); d.className = "card";
    const ts = (c.t || []).map(t => `<span class="tag">${t}</span>`).join("");
    d.innerHTML = `<div class="card-name">${c.n}</div><div>${ts}</div><div class="atk">${c.a}</div>`;
    return d;
  }

  function resetGame() { if(confirm('全リセットしますか？')) database.ref('games/'+roomId).set(null); }
  function resetLocalUI() {
    document.getElementById("setup-area").style.display = "block";
    document.getElementById("end-screen").style.display = "none";
    document.getElementById("hand").innerHTML = ""; document.getElementById("myField").innerHTML = "";
    document.querySelector(".status span").textContent = "待機中";
  }
  function cancelActions(e) {
    if (e.target.closest('.card') || e.target.closest('#oppArea') || e.target.tagName === 'BUTTON') return;
    selectedIdx = null; sacrificeHandIdx = null; updateUI();
  }
  function showEnd(m) {
    const s = document.getElementById("end-screen");
    document.getElementById("end-message").textContent = m;
    s.style.display = "flex";
  }
</script>
</body>
</html>
