<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>TCG Master Ver.41</title>
<style>
  :root { --primary: #007aff; --danger: #ff3b30; --success: #34c759; --warning: #ff9500; --dark: #1c1c1e; }
  body { margin: 0; padding: 16px; font-family: -apple-system, sans-serif; background: #f0f0f0; user-select: none; -webkit-touch-callout: none; }
  
  .info-bar { background: #333; color: white; padding: 10px; border-radius: 8px; margin-bottom: 12px; font-size: 13px; line-height: 1.6; }
  .info-bar b { color: #5ac8fa; }
  .status { margin-bottom: 8px; font-size: 14px; text-align: center; height: 45px; }
  .active-turn { color: var(--primary); font-weight: bold; border: 2px solid var(--primary); padding: 6px; border-radius: 8px; background: #e6f0ff; display: block; }

  #editor-view, #game-view { display: none; }
  .view-card { background: #fff; padding: 20px; border-radius: 12px; border: 3px solid var(--primary); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
  .master-list { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; padding: 10px; background: #eee; border-radius: 8px; justify-content: center; max-height: 300px; overflow-y: auto; }
  .deck-count { font-size: 24px; font-weight: bold; color: var(--danger); text-align: center; margin-bottom: 10px; }

  .field-container { display: flex; flex-direction: column; gap: 10px; background: #ddd; padding: 10px; border-radius: 8px; margin: 15px 0; min-height: 260px; border: 2px dashed #999; }
  .field-side { display: flex; gap: 8px; justify-content: center; min-height: 115px; align-items: center; }
  
  .card { width: 85px; height: 115px; background: white; border-radius: 6px; padding: 6px; text-align: center; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; flex-direction: column; border: 2px solid transparent; flex-shrink: 0; box-sizing: border-box; transition: 0.2s; position: relative; cursor: pointer; }
  .card-name { font-weight: bold; height: 2.4em; overflow: hidden; line-height: 1.2; }
  .tag { font-size: 8px; padding: 1px 4px; border-radius: 3px; background: #eee; margin: 2px; display: inline-block; border: 0.5px solid #ccc; }
  .atk { color: var(--danger); font-weight: bold; font-size: 14px; margin-top: auto; }
  .atk::before { content: "ATK "; font-size: 9px; }

  .exhausted { opacity: 0.5; filter: grayscale(1); }
  .selected { border-color: var(--warning); box-shadow: 0 0 10px var(--warning); transform: translateY(-5px); }
  .targetable { border-color: var(--danger); animation: blink 0.8s infinite; }
  .sacrifice-target { border-color: var(--primary); animation: blink 0.8s infinite; }
  .direct-target { background: var(--danger) !important; color: white !important; animation: blink 0.5s infinite; border-radius: 4px; padding: 0 4px; }

  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
  button { width: 100%; height: 50px; font-size: 16px; border: none; border-radius: 8px; background: var(--primary); color: white; margin-bottom: 10px; font-weight: bold; cursor: pointer; }
  #hand { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 10px; }

  /* モーダル */
  .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 1000; }
  .modal-content { background: white; width: 85%; max-width: 300px; padding: 20px; border-radius: 15px; text-align: center; }
  .modal-name { font-size: 20px; font-weight: bold; margin-bottom: 5px; }
  .modal-atk { font-size: 18px; color: var(--danger); font-weight: bold; margin-bottom: 15px; }
  .modal-effect { font-size: 14px; color: #444; text-align: left; background: #f9f9f9; padding: 10px; border-radius: 8px; min-height: 50px; }

  .end-screen { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); color:white; display:none; flex-direction:column; align-items:center; justify-content:center; z-index:100; }
</style>
</head>
<body onclick="cancelActions(event)">

  <div id="cardModal" class="modal-overlay" onclick="closeModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="modal-name" id="mName"></div>
      <div class="modal-atk" id="mAtk"></div>
      <div class="modal-effect" id="mEffect"></div>
      <button onclick="closeModal()" style="margin-top:20px; height:40px; background:#8e8e93">閉じる</button>
    </div>
  </div>

  <div id="editor-view" class="view-card">
    <h2>デッキ作成</h2>
    <div class="deck-count">残り: <span id="deckRemain">18</span>枚</div>
    <div id="masterList" class="master-list"></div>
    <button onclick="randomDeck()" style="background:var(--success)">おまかせ作成</button>
    <button id="saveDeckBtn" onclick="saveDeckToFirebase()" disabled>サーバーへ保存</button>
  </div>

  <div id="game-view">
    <div class="info-bar">
      <div>ROOM: <b id="displayRoomId">-</b> | <b id="displayMyName">-</b></div>
      <div>ダメージ: 自 <span id="myDamage">0</span>/3 | 敵 <span id="oppDamage">0</span>/3</div>
      <div id="oppArea">直接攻撃: <b id="displayOppName">-</b></div>
    </div>
    <div id="setup-area"><button onclick="startGameSync()" style="background:var(--success)">対戦開始</button></div>
    <div class="status"><span id="currentTurnOwner">待機中</span></div>
    <div class="field-container">
      <div id="opponentField" class="field-side"></div>
      <hr style="width:100%; border:0; border-top:1px solid #bbb;">
      <div id="myField" class="field-side"></div>
    </div>
    <button id="turnEndBtn" onclick="endTurn()" style="background:var(--warning)" disabled>ターン終了</button>
    <div id="hand"></div>
    <button onclick="resetGame()" style="background:var(--danger); margin-top:20px; font-size:12px; height:30px;">全リセット</button>
  </div>

  <div id="end-screen" class="end-screen">
    <h1 id="end-message"></h1>
    <button onclick="resetGame()" style="width:200px; background:var(--danger)">終了</button>
  </div>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyCzUHmyYcQlYkJmeXX5Cxp_fNFkonOSE3I",
    authDomain: "tcgtk-51f73.firebaseapp.com",
    databaseURL: "https://tcgtk-51f73-default-rtdb.firebaseio.com",
    projectId: "tcgtk-51f73",
    storageBucket: "tcgtk-51f73.firebasestorage.app",
    messagingSenderId: "379251900306",
    appId: "1:379251900306:web:beeb1989bedcca4dcbcb4b"
  };
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();

  const params = new URLSearchParams(window.location.search);
  const roomId = params.get("room");
  const myPlayerId = params.get("player") || "player1";
  const opponentPlayerId = myPlayerId === "player1" ? "player2" : "player1";

  const cardPool = [
    {n:"火の精霊", a:400, t:["火"], e:"標準的な火のモンスター。"},
    {n:"水の精霊", a:400, t:["水"], e:"標準的な水のモンスター。"},
    {n:"光の騎士", a:700, t:["光"], e:"高い攻撃力を持つ聖なる騎士。"},
    {n:"雷神", a:800, t:["光"], e:"伝説の雷を操る神。"},
    {n:"戦乙女", a:750, t:["光"], e:"戦場を舞う高潔な乙女。"},
    {n:"大盾兵", a:300, t:["地"], e:"防御に優れた頑強な兵士。"},
    {n:"スライム", a:100, t:["水"], e:"最弱だが、時に奇跡を起こす。"},
    {n:"ドラゴン", a:900, t:["火", "特殊"], e:"【生贄】出す時に自分の場の1体を破壊する必要がある。"},
    {n:"ゴブリン", a:200, t:["地", "仲間"], e:"【仲間】出す時、デッキに別のゴブリンがいれば場に呼ぶ。"},
    {n:"ナイト", a:500, t:["闇"], e:"闇に染まった孤独な騎士。"},
    {n:"不死鳥", a:1000, t:["火", "特殊"], e:"【生贄】出す時に自分の場の1体を破壊する必要がある。"},
    {n:"死神", a:700, t:["闇", "即死"], e:"【即死】攻撃時、相手の数値を無視して破壊する。"}
  ];

  if (roomId) { document.getElementById("game-view").style.display = "block"; initGameLogic(); }
  else { document.getElementById("editor-view").style.display = "block"; initEditorLogic(); }

  // --- モーダル制御 ---
  let pressTimer;
  function startPress(c) { pressTimer = setTimeout(() => {
    document.getElementById("mName").textContent = c.n;
    document.getElementById("mAtk").textContent = "ATK: " + c.a;
    document.getElementById("mEffect").textContent = c.e || "効果なし";
    document.getElementById("cardModal").style.display = "flex";
  }, 500); }
  function cancelPress() { clearTimeout(pressTimer); }
  function closeModal() { document.getElementById("cardModal").style.display = "none"; }

  // --- デッキ編集 ---
  let currentDeck = [];
  function initEditorLogic() {
    const list = document.getElementById("masterList");
    cardPool.forEach(c => {
      const el = createCardEl(c);
      el.onclick = () => { if(currentDeck.length < 18) { currentDeck.push({...c}); updateEditorUI(); } };
      list.appendChild(el);
    });
    database.ref(`decks/${myPlayerId}`).get().then(s => { if(s.exists()){ currentDeck = s.val(); updateEditorUI(); }});
  }
  function updateEditorUI() {
    document.getElementById("deckRemain").textContent = 18 - currentDeck.length;
    document.getElementById("saveDeckBtn").disabled = (currentDeck.length !== 18);
  }
  function randomDeck() {
    currentDeck = [];
    for(let i=0; i<18; i++) currentDeck.push({...cardPool[Math.floor(Math.random()*cardPool.length)]});
    updateEditorUI();
  }
  function saveDeckToFirebase() {
    database.ref(`decks/${myPlayerId}`).set(currentDeck).then(() => alert("保存完了"));
  }

  // --- 対戦ロジック ---
  let myHand=[], myField=[], oppField=[], isMyTurn=false, selectedIdx=null, sacrificeHandIdx=null, turnCount=0;

  function initGameLogic() {
    document.getElementById("displayRoomId").textContent = roomId;
    document.getElementById("displayMyName").textContent = myPlayerId;
    document.getElementById("displayOppName").textContent = opponentPlayerId;

    database.ref(`games/${roomId}`).on("value", snap => {
      const data = snap.val();
      if (!data) { resetLocalUI(); return; }
      turnCount = data.turnCount || 0;
      const me = data[myPlayerId] || {}; const opp = data[opponentPlayerId] || {};
      if (me.damage >= 3) showEnd("敗北"); else if (opp.damage >= 3) showEnd("勝利");
      document.getElementById("myDamage").textContent = me.damage || 0;
      document.getElementById("oppDamage").textContent = opp.damage || 0;
      if (data.currentTurn) {
        document.getElementById("setup-area").style.display = "none";
        isMyTurn = (data.currentTurn === myPlayerId);
        if (isMyTurn && window.lastTurnKey !== (data.currentTurn + turnCount)) {
          window.lastTurnKey = (data.currentTurn + turnCount); setTimeout(autoDraw, 600);
        }
      }
      myHand = me.handList || []; myField = me.field || []; oppField = opp.field || [];
      updateUI();
    });
  }

  async function startGameSync() {
    const [mS, oS] = await Promise.all([database.ref(`decks/${myPlayerId}`).get(), database.ref(`decks/${opponentPlayerId}`).get()]);
    if (!mS.exists() || !oS.exists()) return alert("デッキ未作成");
    const mD = mS.val().sort(() => Math.random() - 0.5); const oD = oS.val().sort(() => Math.random() - 0.5);
    database.ref(`games/${roomId}`).set({
      currentTurn: "player1", turnCount: 1,
      [myPlayerId]: { deck: mD.slice(3), handList: mD.slice(0, 3), field: [], damage: 0 },
      [opponentPlayerId]: { deck: oD.slice(3), handList: oD.slice(0, 3), field: [], damage: 0 }
    });
  }

  function autoDraw() {
    database.ref(`games/${roomId}/${myPlayerId}`).get().then(s => {
      const d = s.val(); if (!d || !d.deck || d.deck.length === 0) return;
      const newD = [...d.deck]; const c = newD.shift();
      database.ref(`games/${roomId}/${myPlayerId}`).update({ deck: newD, handList: [...(d.handList||[]), c] });
    });
  }

  async function playCard(i) {
    if (!isMyTurn) return;
    const c = myHand[i];
    if ((c.n==="不死鳥" || c.n==="ドラゴン") && myField.length===0) return alert("生贄不足");
    if ((c.n==="不死鳥" || c.n==="ドラゴン")) { sacrificeHandIdx = i; updateUI(); return; }
    if (myField.length >= 3) return alert("場がいっぱい");

    let h = [...myHand]; h.splice(i, 1); let f = [...myField, {...c, hasAttacked:false}];
    if (c.n === "ゴブリン") {
      const snap = await database.ref(`games/${roomId}/${myPlayerId}/deck`).get();
      let d = snap.val() || []; const gI = d.findIndex(dc => dc.n === "ゴブリン");
      if (gI !== -1 && f.length < 3) { f.push({...d.splice(gI, 1)[0], hasAttacked: false}); database.ref(`games/${roomId}/${myPlayerId}/deck`).set(d); }
    }
    database.ref(`games/${roomId}/${myPlayerId}`).update({ handList: h, field: f });
  }

  function completeSacrifice(fi) {
    const c = myHand[sacrificeHandIdx];
    let h = [...myHand]; h.splice(sacrificeHandIdx, 1);
    let f = [...myField]; f.splice(fi, 1); f.push({...c, hasAttacked: false});
    sacrificeHandIdx = null;
    database.ref(`games/${roomId}/${myPlayerId}`).update({ handList: h, field: f });
  }

  function attack(oi) {
    const mc = myField[selectedIdx]; const oc = oppField[oi];
    let mf = [...myField], of = [...oppField]; mf[selectedIdx].hasAttacked = true;
    if (mc.n === "死神" || mc.a > oc.a) of.splice(oi, 1);
    else if (mc.a < oc.a) mf.splice(selectedIdx, 1);
    else { mf.splice(selectedIdx, 1); of.splice(oi, 1); }
    selectedIdx = null;
    database.ref(`games/${roomId}`).update({ [`/${myPlayerId}/field`]: mf, [`/${opponentPlayerId}/field`]: of });
  }

  function directAtk() {
    database.ref(`games/${roomId}/${opponentPlayerId}/damage`).transaction(d => (d || 0) + 1);
    let f = [...myField]; f[selectedIdx].hasAttacked = true;
    database.ref(`games/${roomId}/${myPlayerId}/field`).set(f);
    selectedIdx = null;
  }

  function endTurn() {
    selectedIdx = null; sacrificeHandIdx = null;
    database.ref(`games/${roomId}`).transaction(d => {
      if (d) { d.currentTurn = opponentPlayerId; d.turnCount = (d.turnCount || 0) + 1;
        [d.player1, d.player2].forEach(p => p && p.field && p.field.forEach(c => c.hasAttacked = false));
      } return d;
    });
  }

  function updateUI() {
    const sEl = document.querySelector(".status span");
    sEl.textContent = isMyTurn ? (turnCount===1 ? "先行：攻撃不可" : (sacrificeHandIdx!==null ? "生贄選択" : "自ターン")) : "敵ターン";
    sEl.parentElement.className = isMyTurn ? "status active-turn" : "status";
    document.getElementById("turnEndBtn").disabled = !isMyTurn;

    const oppN = document.getElementById("displayOppName");
    if (isMyTurn && selectedIdx !== null && oppField.length === 0) {
      oppN.classList.add("direct-target"); oppN.onclick = directAtk;
    } else { oppN.classList.remove("direct-target"); oppN.onclick = null; }

    const hD = document.getElementById("hand"); hD.innerHTML = "";
    myHand.forEach((c, i) => { const el = createCardEl(c); if(sacrificeHandIdx===i) el.classList.add("selected"); el.onclick = (e) => { e.stopPropagation(); playCard(i); }; hD.appendChild(el); });

    const mF = document.getElementById("myField"); mF.innerHTML = "";
    myField.forEach((c, i) => { const el = createCardEl(c);
      if (sacrificeHandIdx !== null) { el.classList.add("sacrifice-target"); el.onclick = () => completeSacrifice(i); }
      else { if (c.hasAttacked) el.classList.add("exhausted"); if (isMyTurn && !c.hasAttacked) { el.onclick = (e) => { e.stopPropagation(); selectedIdx = (selectedIdx === i) ? null : i; updateUI(); }; if (selectedIdx === i) el.classList.add("selected"); } }
      mF.appendChild(el);
    });

    const oF = document.getElementById("opponentField"); oF.innerHTML = "";
    oppField.forEach((c, i) => { const el = createCardEl(c); if(selectedIdx !== null) { el.classList.add("targetable"); el.onclick = () => attack(i); } oF.appendChild(el); });
  }

  function createCardEl(c) {
    const d = document.createElement("div"); d.className = "card";
    // 長押しイベント (マウスとタッチ両対応)
    d.onmousedown = () => startPress(c); d.onmouseup = cancelPress; d.onmouseleave = cancelPress;
    d.ontouchstart = (e) => { startPress(c); }; d.ontouchend = cancelPress;
    const ts = (c.t || []).map(t => `<span class="tag">${t}</span>`).join("");
    d.innerHTML = `<div class="card-name">${c.n}</div><div>${ts}</div><div class="atk">${c.a}</div>`;
    return d;
  }

  function resetGame() { if(confirm('リセット？')) database.ref('games/'+roomId).set(null); }
  function resetLocalUI() {
    myHand=[]; myField=[]; oppField=[]; selectedIdx=null; sacrificeHandIdx=null; turnCount=0; isMyTurn=false;
    document.getElementById("setup-area").style.display="block"; document.getElementById("end-screen").style.display="none";
    document.getElementById("hand").innerHTML=""; document.getElementById("myField").innerHTML=""; document.getElementById("opponentField").innerHTML="";
    document.getElementById("myDamage").textContent="0"; document.getElementById("oppDamage").textContent="0";
  }
  function cancelActions(e) { if (e.target.closest('.card') || e.target.closest('#oppArea')) return; selectedIdx = null; sacrificeHandIdx = null; updateUI(); }
  function showEnd(m) { const s = document.getElementById("end-screen"); document.getElementById("end-message").textContent = m; s.style.display = "flex"; }
</script>
</body>
</html>
